#define mbslave1
#include "ina90.h"
#include "mbsl1.h"
#include "led.h"
#include "types.h" 
#include "hist.h"
#include "base.h"
#include "zerodef.h"
#include <iom128.h>
//#define ENABLE_BIT_DEFINITIONS 1


struct isr_cntx u1;
extern UINT getcrc(UCHAR *puchMsg, UINT usDataLen);
char len1;
char *txf1;

enum tstates {sync,wait1,rx,senpr,senbody,senpost}  ;
void initmb1(unsigned int speed,char par,char ad){
//DDRE_Bit2=1; //установили бит управления передатчиком на вывод
txen1ini
SEND1OFF;
 UCSR1A=2; //установили бит  U2X
 UCSR1B = (1<<RXEN1)|(1<<TXEN1);
 UCSR1C=((1<<1)|(1<<2));//УСТАНОВИЛИ 8БИТ ДАННЫХ И 1 СТОП
 u1.addr=ad;
 switch (par){
   case none:{ 
     UCSR1C&=~((1<<UPM11)|(1<<UPM1Z));
     break;
   };  
   case even:{ 
     UCSR1C|= 1<<UPM11;
     UCSR1C&=~(1<<UPM1Z);
     break;
   };  
   case odd:{ 
     UCSR1C|= 1<<UPM11;
     UCSR1C|=1<<UPM1Z;
     break;
   };  
 };
/* регистр tccr1
 7 =1 - не нужен PWM
 6,3 = zero - обычная мода
 5,4 =zero - не используется выход модуляции
 2,1,zero - предделитель
*/
  switch (speed){
    case 48:{
      TCCR1CH=CTC124_1;// CTC мода предделитель 1124;
      UBRR1L=383-256; 
      UBRR1H = (unsigned char)(383>>8);
      UBRR1L = (unsigned char)383;
      t25=83;
      t35=116;
      t45=OCR1T=148;
      
      break;
    }case 96:{
      t25=41;
      t35=58;
      TCCR1CH=CTC124_1; // CTC мода предделитель 1124;
      t45=OCR1T=74;
      UBRR1H = zero;
      UBRR1L = 191;
      
      break;
    }case 192:{
      t25=82;
      t35=116;
      TCCR1CH=CTC256_1; // CTC мода предделитель 256;
      UBRR1H = zero;
      UBRR1L = 95;
      t45=OCR1T=149;
      
      break;
    }case 384:{
      t25=41;
      t35=58;
      TCCR1CH=CTC256_1;
      UBRR1H = zero;
      UBRR1L = 47;    
      t45=OCR1T=74;
      break;
    }
    case 576: {
      t25=28; 
      t35=39;
      TCCR1CH=CTC256_1; 
      UBRR1H = zero;
      UBRR1L = 31;
      t45=OCR1T=49;
      break;
    }
    case 1152: {
//    t25=14;
//    t35=21;
      t25=41; 
      t35=58;

      TCCR1CH=CTC256_1; 
      UBRR1H = zero;
      UBRR1L = 15;
//      t45=OCR1T=24;
      t45=OCR1T=74;
      break;
    }
    default: {
      t25=82;    
      t35=116;
      TCCR1CH=CTC256_1; // скорость по умолчанию 19211
      UBRR1H = 149;
      UBRR1L = zero;
      t45=OCR1T=149;
   };                 
  };
//  u1.state=wait1;
  u1.state=sync;
  TCNT1CH=zero;
//  TIMSK|=2;//разрешили прерывание от таймера  по COMP !!!!!!
  OCIE1CH=1;
  UCSR1B|=(1<<RXCIE1); //разрешили прерывания от приемника
};
/////////////////////////////////////////////////////////////////////////////////////////////////////////

#pragma vector=USART1_RXC_vect
__interrupt void rx1_isr() {

//redon3
  if((u1.state==sync)){goto error_rx;};
  if (u1.state==wait1){

    TCNT1CH=zero;
//    TIFR_Bit1=1; //сбросили флаг прерывания от таймера, если он был
      OCF1CH=1;
//    TIMSK_Bit1=1; //разрешили прерывания от таймера
    OCIE1CH=1;

    if((UCSR1A&((1<<FE1)|(1<<UPE1)))!=zero){goto error_rx;};//была проверка на корректность кадра -стоп бит и  паритет /!!!!!!!
//    gron3;
    u1.state=rx;
    u1.rbuf[u1.l++]=UDR1;
//    u1.rbuf[u1.l++]=b;
    goto erx;     
  }else { //осталось состояние приема тела кадра. При остальных прерываний быть не должно
//   gron3  
     if(TCNT1CH<t45){ 
//        if(((UCSR1A&16)!=zero)){goto error_rx;};//была проверка на корректность кадра -стоп бит и  паритет
          if((UCSR1A&((1<<FE1)|(1<<UPE1)))!=zero){goto error_rx;};//была проверка на корректность кадра -стоп бит и  паритет /!!!!!!!
        TCNT1CH=zero; u1.rbuf[u1.l++]=UDR1; 
        goto erx;
    }
  }
//   TCNT1CHCH=zero; u1.rbuf[u1.l++]=b;}
  // если же не уложились в интервал - сбрасываем кадр 
  u1.l=zero; //сбрасываем  кадр.
error_rx:
//  off3 ;redon3; 
//  {char b;     b=UDR1; }
  getrx1 
  TCNT1CH=zero;u1.state=sync; 
erx: 
// off3  
};   
///////////////////////////////////////////////////////////////////////////////////////////////////////
void sen1(char *outbuf,char l){
  __disable_interrupt();
  TCNT1CH=zero;
  SEND1ON;   
  //OCR1T=t35;
  OCR1T=t35;
  u1.state=senpr;
  OCIE1CH=1; //!!!! разрешаем прерывания от таймера

  txf1=outbuf;len1=l;
  __enable_interrupt();

}
///////////////////////////////////////////////////////////////////////////////////////////////////
extern UCHAR maxc;
extern UINT  ramb[ramm];
char fc16handl1(){ //функция обработки fc=16 возвращает zero или Exeption
char i;
UINT rg;
  rg=(u1.rbuf[2]<<8)+u1.rbuf[3];
  if (rg==0x777){reset_cpu();  return zero;}; //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  if ((rg==0x778)&&(u1.rbuf[8]==0xaa)){wr_fl=1;  return zero;};//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  if ((u1.rbuf[4]!=zero)|((u1.rbuf[5]*2)!=u1.rbuf[6])) return 3;//illegal data value
//  rg=(u1.rbuf[2]<<8)+u1.rbuf[3];
  if ((rg+u1.rbuf[5])>rammax)   return 2;//illegal data address;
  
  if ((rg>eepromm)&&(rg<rammin))return 7;
  if (rg>=rammin){
    UINT * intp; 
    intp=&(ramb[rg-rammin]);//inp - указатель на текущий записываемый регистр; 
    for(i=zero;i<u1.rbuf[5];i++){ //запись в базу данных RAM
      __disable_interrupt();
      *intp=(u1.rbuf[7+i]<<8)+u1.rbuf[7+i+1];
      __enable_interrupt();
      rg++;
    }; 
    return zero; 
  }
  if ((rg==1)||(rg==2))
     if(wr_fl==1) {return 2;}//illegal data address; ;
        else {wr_fl=1;   return wrblock_ini(rg,u1.rbuf[5],(UINT*)&(u1.rbuf[7]));}
     
  //обработка записи в EEPROM
//  _clis
//  if (maxc!=zero){SREG=sregt; return 6;};//slave device busy уже идет обработка записи в eeprom c модбаса
//  if 
   return wrblock_ini(rg,u1.rbuf[5],(UINT*)&(u1.rbuf[7]));
//  return zero;
}
char reinitu1(){
char b;
  u1.l=zero;
  u1.state=wait1;
  b=UDR1;
  b=UDR1;
  b=UDR1;
  UCSR1B|=(1<<RXCIE1); //разрешили прерывания от приемника};
  return b;
}  
////////////////////////////////////////////////////////////////////////////////////////////////////
//постановка на передачу exeption code
sendexept1(char ex){
UINT crc;
  u1.tbuf[zero]=u1.addr;
  u1.tbuf[1]=u1.rbuf[1]|C8Z;
  u1.tbuf[2]=ex;
  crc=getcrc((UCHAR *)&(u1.tbuf),3);
  u1.tbuf[3]=crc >> 8;
  u1.tbuf[4]=crc; //1xFF;
  sen1((char *)&u1.tbuf,5);
};
#define maxreg 64
// форк обработчика принятого кадра (в настоящее время просто выполняется на прерывании с открытыми прерываниями
void rec_frm_fork1(){
unsigned char b;
UINT first,rg;
char *ptr;
//      redon4
//   if(getcrc((UCHAR *)&u1.rbuf,u1.l)!=zero){reinitu1();goto end_isr;};
      if(getcrc((UCHAR *)&u1.rbuf,u1.l)!=zero){reinitu1();return;};
      if((u1.rbuf[5]>maxreg)|(u1.rbuf[4]!=zero)){sendexept1(3); return;};   
      if (u1.rbuf[1]==3){//обработка фукнкции чтения холдинг-регистров
//      off4
//      gron4  
//      if (u1.rbuf[zero]==zero)goto end_isr; //broadcast
              // адрес регистра
   	  first=u1.rbuf[2]<<8;
	  first += u1.rbuf[3];

          // количество регистров
//	  if((u1.rbuf[5]>127)|(u1.rbuf[4]!=zero)){sendexept1(3); goto end_isr;};
	  if((u1.rbuf[5]>maxreg)|(u1.rbuf[4]!=zero)){sendexept1(3); return;};
	  u1.tbuf[zero]=u1.addr;
	  u1.tbuf[1]=3;//fc
	  u1.tbuf[2]=u1.rbuf[5]*2; //byte count;
	  ptr=&u1.tbuf[3];
	  {UINT i;
          for (i=first;i<first+u1.rbuf[5];i++){
//             if ((b=getrg(i,&rg))!=zero){sendexept1(b); goto end_isr;};  	
          if ((b=getrg(i,&rg))!=zero){sendexept1(b); return;};  	
             *(ptr++)=rg>>8;
             *(ptr++)=rg&Cff;
          };  
          }
          {UINT crc;
             crc=getcrc((UCHAR *)&u1.tbuf,u1.tbuf[2]+3);
             *(ptr++)=crc >> 8;
             *(ptr++)=crc & Cff;
                        
          };
          sen1((char *)&u1.tbuf,u1.tbuf[2]+5);
//          goto end_isr;
          return;
     }
     if (u1.rbuf[1]==16){//обработка функции записи регистров
        b=fc16handl1();
//        if (b!=zero) {sendexept1(b);goto end_isr;}
        if (b!=zero) {sendexept1(b);return;}
        else {
          u1.tbuf[zero]=u1.addr;
	  u1.tbuf[1]=16;//fc
	  u1.tbuf[2]=u1.rbuf[2]; 
	  u1.tbuf[3]=u1.rbuf[3]; 
	  u1.tbuf[4]=u1.rbuf[4]; 
	  u1.tbuf[5]=u1.rbuf[5]; 
          {UINT crc;
             crc=getcrc((UCHAR *)&u1.tbuf,6);
             u1.tbuf[6]=crc >> 8;
             u1.tbuf[7]=crc & Cff;
          };
          sen1((char *)&u1.tbuf,8);
//          goto end_isr;
          return;
        }
     }
     if (u1.rbuf[1]==8){
     //обработка функции диагностики
       sen1((char *)&u1.rbuf,u1.l);
//       goto end_isr;
       return;
     }
     sendexept1(5);//ILLEGAL FUNCTION другие функции не поддерживаются
};

// функция возвращает значение регистра с заданным адресом в переменной RG и zero в случае успешного завершения
// в случае невозможности чтения регистра функция возвращает еxeption для отправки пользователю
extern char getrg(UINT address,UINT * rg);
////////////////////////////////////////////////////////////////////////////////////////////////////////////
#pragma vector=TIMERch1_COMP_vect
__interrupt void tch1_comp_isr(){
//  gronw
  UCSR1B&=~(1<<RXCIE1);//запрещаем прерывания от приемника
  OCIE1CH=zero; //!!!! запрещаем прерывания от таймера OCIE1=zero

  if (u1.state==sync){reinitu1();goto end_isr;}
  _SEI();//открыли прерывания - остальное работает
 // redon4
  if (u1.state==rx){
//       redon4
   //проверяем корректность принятого кадра
//   b=u1.l;
//gron4
      if ((u1.l<8)|(u1.addr!=u1.rbuf[zero])){reinitu1();goto end_isr;};
// redon4
     rec_frm_fork1(); 
//     off4
     goto end_isr;
  };  
  if(u1.state==senpr){ // передавали преамбулу
       u1.state=senbody;    
       UCSR1B|=(1<<UDRIE1)|(1<<TXEN1);  //открыли прерывания (таймер запрещен)

//       delayloop(51); 
       goto end_isr;
       
//       return;
   }
   if(u1.state==senpost){ // передавали постамбулу
       u1.state=1;    
       SEND1OFF;   
       reinitu1();  
//       return;
          
       goto end_isr; 
   }
   u1.state=sync;
end_isr:;
 
// offw
};

//////////////////////////////////////////////////////////////////////////////////////////////////////////
#pragma vector=USART1_UDRE_vect
__interrupt void tx1_isr()
{

  if (len1!=zero){
    len1=len1-1;
    UDR1=*txf1++;

  }
  else {
     //запрещаем прерывания от передатчика,
//     UCSR1B&=~(1<<5);
    UCSR1B&=~(1<<UDRIE1);
    u1.state=senpost;//переходим в состояние передачи постамбулы.
//    OCR1T=t35;
    OCR1T=t35;
    TCNT1CH=zero; 
    OCF1CH=1; //сбросили флаг прерывания от таймера, если он был
    OCIE1CH=1; //разрешили прерывания от таймера

  }
 

// redoff(); 
};

char sendstart1(char *outbuf,char l){
    UCSR1A&=~(1<<TXC1);  
    UDR1=*outbuf++;
    len1=--l;  
    txf1=outbuf;
    UCSR1B|=(1<<UDRIE1)|(1<<TXEN1); 
    return zero;
};
